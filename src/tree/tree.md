基础知识：
任何有根有序的多叉树都可以转换为二叉树
任意节点v到根节点r经过边的个数+1为节点v的深度，根节点r深度为1
任意节点v孩子的个数为其度数degree
深度的最大值为数的高度
二叉树为节点度数都不超过2的树，不含度数为1的二叉树又称为真二叉树
每个节点的孩子均不超过k的有根树，称为k叉树
同一节点的所有孩子之间具有某一线性次序的树称为有序树
二叉树一般都默认是有序二叉树
有序多叉树+长子兄弟表示法=二叉树
节点数为n的完全二叉树，高度为log2n取下整+1
高度为h的满二叉树，节点数为2^h - 1
任何一个二叉树是二叉搜索树，当前仅当其中序遍历单调非降
二叉搜索树操作的复杂度取决于树的高度，当树退化成链表时，复杂度为O(n)，因此想到平衡二叉搜索树(理想平衡、适度平衡)
若将树高限制为“渐进意义下不超过O(logN)”，则AVL树、伸展树、红黑树、kd-树等都属于适度平衡，从而保证每次操作在O(logN)的时间完成
若两颗二叉树中序遍历相同，则称他们彼此等价
前序遍历和中序遍历可以唯一确定一颗树
后序遍历和中序遍历可以唯一确定一棵树
前序遍历和后序遍历不能唯一确定一棵树

基本操作：
前中后层序遍历
两种遍历结果组合中整个树
二叉搜索树的插入、删除
平衡二叉树的zig,zag

技巧：
递归技巧
若递归深度为n的方法的计算结果依赖于第n+1层，那么结果通过方法返回值传递
若递归深度为n+1的方法的计算结果依赖于第n层，那么结果通过参数传递
若干递归有返回值，那么返回值一定是从递归树的叶子节点传递回来的
分而治之
减而治之
BST可增加虚拟节点，统一操作，虚拟节点也满足BST
递归时，若第n层计算依赖于第n+1层，可考虑自底向上的思路，即在左右子树递归完后，进行本层节点的逻辑处理，例：814
自底向上的构建一棵树，计算本层节点node,node.left=递归，node.right=递归
可通过对二叉树进行编号，将二叉树存到数组中，左子树为2*parentId右子树为2*parentId+1，例：662

类型：
分治法：问题完全可以切分成左子树，右子树的问题

：问题需要综合考虑左右子树的情况与根节点的情况

遍历时，考虑各种遍历方案

自底向上思考
LeetCode_124_Binary_Tree_Maximum_Path_Sum
LeetCode_687_Longest_Univalue_Path